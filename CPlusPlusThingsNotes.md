# CPlusPlusThings Notes

## const

**const 和 #define 的区别**

- const 有类型，编辑器能进行安全检查
- #define是在预编译的时候简单的进行替换，

**extern与const**

- extern可以理解为申明但不定义，可以在别的源文件中定义，然后在当前源文件声明并使用。
- 由于const一般申明和定义同时进行，所以在其他源文件中要使用 `extern const int e = 12`, 然后在当前源文件中也要使用 `extern const int e`来申明。

**指针与const**

- const位于*的左侧，则const用来修饰指针所指的对象，指针本身可以修改，指针所指对象不能修改

- const位于*的右侧，则const用来修饰指针，指针本身不能修改，指针所指的对象可以修改。

- 不能使用指向常量的指针修改所指对象，即时它指向了非const的对象，比较绕。

  ```cpp
  const int *ptr;
  int val = 3;
  ptr = &val //ok
  *ptr = 3 //error
  ```

- const指针必须进行初始化。

**函数与const**

- const在参数列表中，`const int var 和 int* const var `都无意义，前者按值传递，const就相当于修饰的拷贝，所以无意义。后者指针本身不可变，但是本身也是拷贝，所以无意义。
- 参数列表中， `const char *src` 是有意义的，可以保护该指针所指的变量在函数内部不被修改，这也是const的主要作用之一。
- 参数为引用 `const func(const A &a)`，可以增加效率的同时防止修改！

**类与const**

- 类中的const成员变量必须通过初始化列表进行初始化
- 类中的const成员函数只能访问const成员函数，非const成员函数可以访问所有成员函数
- 类中的const成员变量可以直接在类定义中用`static const int a=10` 或者 `const int apple=10` C++11是支持的

## static

**函数中的static变量**

- static变量只被初始化一次，在函数内部申明的static变量，在程序生命周期内绑定给该函数。时间上为全局变量，空间上为局部变量。

**类中的static变量**

- 类中的static变量由所有类实例共享，任何一个类的实例对类的static变量修改后都会修改所有实例，因为他们共享该static变量。
- 类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化，初始化的时候不加关键字static

**类的static实例**

- 类的static实例存在于整个程序生命周期，在main函数后调用析构函数。
- 非静态成员引用必须与特定对象相对，static函数只能调用static函数和static对象，因为调用类的static函数类似调用一个非类成员的自由函数。
- static还有限定访问范围的作用，可能是由于static是和代码文件绑定的。

## this

this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。

- 在类的非静态成员函数中返回类实例本身的时候，直接使用return *this
- this指针在非常函数中被解析成A* const this, 在常函数中被解析成const A* const this

## inline

**类中的inline**

- inline要想生效，要与函数的定义放在一起，是一种用于定义的关键字而不是声明。

**虚函数与inline**

- 虚函数通过指针调用呈现多态性时，需要在运行时才能确定，所以不能inline

## sizeof

- 空类的大小为1字节
- 类的大小需要与机器字长对其，例如64位机的类中有一个char 一个虚函数，则大小为1+8=16
- static成员，包括static变量与函数都影响类的大小，因为他们单独存储。所有成员函数都不占用类的空间。
- 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针vptr的大小。
- 派生类虚继承多个虚函数，会继承所有虚函数的vptr

## 函数指针

- `void (*pFun)(int);` 定义了一个指向函数的指针，该指针的输入为int 返回值为void
- `typedef void (*pFun)(int)` 新类型，而不是变量。

## 纯虚函数和抽象类

纯虚函数是指没有函数体的虚函数，直接在声明的时候赋值0，抽象类是指包含纯虚函数的类

- 抽象类中，成员函数可以调用纯虚函数，构造和析构中不能使用纯虚函数
- 如何一个类从抽象类中派生，则它必须实现基类中所有的纯虚函数，才能成为非抽象类。

## 虚函数表

![虚函数表](https://github.com/PerhapsChen/CPlusPlusThings/raw/master/basic_content/vptr_vtable/img/base.jpg)

- 每一个使用虚函数的类和或者从其派生的类都有一个虚函数表，通过维护一个虚函数指针vptr指向该vtable，该vtabel列出了当调用该类的方法时，应该使用基类还是派生类的函数，从而实现了面向对象的重要特性：多态。

